# Rewriting History

## Why We Need Rewrite History

- Squash small, related commits
- Split large commits
- Reword commit messages
- Drop unwanted commits
- Modify commits

**Caution**:_Commits are immutable and rewriting history is dangerous so we should be cautious about changing history_

## Golden Rules of Rewriting History

1. Don't rewrite public history

### Undoing Last Commit

- soft: Removes the commit only
- mixed: Unstage files
- hard: Discards local changes

```zsh
git reset --hard HEAD~1
```

### Reverting Commit

```zsh
git revert HEAD~3..HEAD          # Revert from HEAD~2 to HEAD
git revert --hard HEAD~2         # Revert HEAD~2
git revert --no-commit HEAD~3..  # revert without commit
git revert --abort               # cancel revert
git revert --continue            # continue revert and add single commit for revert
```

### Recovering Lost Commit

```zsh
git reflog                  # see head pointer changes with its entry objects
git reset --hard HEAD@{1}   # use entry object to restore the lost commits
git reflog show feature     # show head pointer changes with its entries for feature branch
```

### Amend last commit

**Scenario**: consider we forgot to add a change to a commit

below we add a file and commit it and then change files and then amend last commit

```zsh
git add .
git commit -m "add file 2"
git add .
git commit --amend
```

**Scenario**: consider we accidentally add a an extra file
below we add a redundant file so we unstage it and then amend the commit

```zsh
git add .
git commit -m "add some code"
git reset --mixed HEAD~1
git status -s
git clean -fd
git add .
git commit -m "changes added"
```
